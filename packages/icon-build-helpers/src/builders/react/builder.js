/**
 * Copyright IBM Corp. 2019, 2019
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

const { camelCase } = require('change-case');
const fs = require('fs-extra');
const path = require('path');
const { rollup } = require('rollup');
const babel = require('rollup-plugin-babel');
const virtual = require('../plugins/virtual');

const { createLogger, displayBanner } = require('@carbon/cli/src/logger');

const logger = createLogger('icons-react');

const BANNER = `/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */`;
const external = ['@carbon/icon-helpers', 'react', 'prop-types'];
const babelConfig = {
  babelrc: false,
  exclude: /node_modules/,
  presets: [
    [
      '@babel/preset-env',
      {
        targets: {
          browsers: ['extends browserslist-config-carbon'],
        },
      },
    ],
    '@babel/preset-react',
  ],
  plugins: [
    '@babel/plugin-transform-react-constant-elements',
    'babel-plugin-dev-expression',
  ],
};

async function builder(metadata, { output }) {
  displayBanner();

  logger.start(`Processing ${metadata.icons.length} icons`);
  const modules = metadata.icons.flatMap((icon) => {
    return icon.output.map((size) => {
      return {
        size: size.size,
        source: createIconFlatExport(
          size.moduleName,
          size.descriptor,
          icon.deprecated
        ),
        entrypoint: createIconEntrypoint(
          size.moduleName,
          size.descriptor,
          icon.deprecated
        ),
        filepath: size.filepath,
        moduleName: size.moduleName,
      };
    });
  });
  logger.stop();

  const sizes = new Map([
    [16, modules.filter((m) => m.size === 16)],
    [20, modules.filter((m) => m.size === 20)],
    [24, modules.filter((m) => m.size === 24)],
    [32, modules.filter((m) => m.size === 32)],
  ]);

  logger.start(`Building size entrypoints`);
  for (const [size, entries] of sizes) {
    logger.start(`Bundling size: ${size}`);
    const directory = path.join(output, `${size}`);
    const packageJsonPath = path.join(directory, 'package.json');
    const packageJson = {
      main: 'lib/index.js',
      module: 'es/index.js',
      sideEffects: false,
    };

    const files = {
      'index.js': `${BANNER}
import React from 'react';
import Icon from './Icon.js';
export { Icon };
`,
    };
    const input = {
      'index.js': 'index.js',
    };

    await fs.ensureDir(directory);
    await fs.writeJson(packageJsonPath, packageJson);

    for (const m of entries) {
      files['index.js'] += `${m.source}
export { ${m.moduleName} as ${m.moduleName.replace(size, '')} };`;
    }

    logger.info('Creating rollup bundle');
    const bundle = await rollup({
      input: input,
      external,
      plugins: [
        virtual({
          './Icon.js': await fs.readFile(
            path.resolve(__dirname, './components/Icon.js'),
            'utf8'
          ),
          ...files,
        }),
        babel(babelConfig),
      ],
    });

    const bundles = [
      {
        directory: path.join(directory, 'es'),
        format: 'esm',
      },
      {
        directory: path.join(directory, 'lib'),
        format: 'commonjs',
      },
    ];

    for (const { directory, format } of bundles) {
      logger.info(`Writing ${format} bundle`);
      const outputOptions = {
        dir: directory,
        format,
        entryFileNames: '[name]',
        banner: BANNER,
      };

      await bundle.write(outputOptions);
    }
    logger.stop();
  }

  logger.stop();

  logger.start('Building package entrypoint');

  const files = {
    'index.js': `${BANNER}
export { default as Icon } from './Icon.js';
`,
  };
  const input = {
    'index.js': 'index.js',
  };
  for (const m of modules) {
    files[m.filepath] = m.entrypoint;
    input[m.filepath] = m.filepath;
    files[
      'index.js'
    ] += `\nexport { default as ${m.moduleName} } from '${m.filepath}';`;
  }

  logger.info('Bundling entrypoint');
  const bundle = await rollup({
    input: input,
    external,
    plugins: [
      virtual({
        './Icon.js': await fs.readFile(
          path.resolve(__dirname, './components/Icon.js'),
          'utf8'
        ),
        ...files,
      }),
      babel(babelConfig),
    ],
  });

  const bundles = [
    {
      directory: path.join(output, 'es'),
      format: 'esm',
    },
    {
      directory: path.join(output, 'lib'),
      format: 'commonjs',
    },
  ];

  for (const { directory, format } of bundles) {
    logger.start(`Writing ${format} bundle`);
    const outputOptions = {
      dir: directory,
      format,
      entryFileNames: '[name]',
      banner: BANNER,
    };

    await bundle.write(outputOptions);
    logger.stop();
  }

  logger.info('Building UMD bundle');
  const umd = await rollup({
    input: 'index.js',
    external,
    plugins: [
      virtual({
        './Icon.js': await fs.readFile(
          path.resolve(__dirname, './components/Icon.js'),
          'utf8'
        ),
        ...files,
      }),
      babel(babelConfig),
    ],
  });

  await umd.write({
    file: path.join(output, 'umd/index.js'),
    format: 'umd',
    name: 'CarbonIconsReact',
    globals: {
      '@carbon/icon-helpers': 'CarbonIconHelpers',
      'prop-types': 'PropTypes',
      react: 'React',
    },
  });
  logger.stop();
}

function createIconFlatExport(moduleName, descriptor, isDeprecated = false) {
  const deprecatedBlock = isDeprecated
    ? `
    if (__DEV__) {
      if (!didWarnAboutDeprecation['${moduleName}']) {
        didWarnAboutDeprecation['${moduleName}'] = true;
        console.warn(
          \`The ${moduleName} component has been deprecated and will be \` +
          \`removed in the next major version of @carbon/icons-react.\`
        );
      }
    }
    `
    : '';
  return createIconSource(moduleName, descriptor, deprecatedBlock);
}

function createIconEntrypoint(moduleName, descriptor, isDeprecated = false) {
  const deprecatedPreamble = isDeprecated
    ? 'let didWarnAboutDeprecation = false;'
    : '';
  const deprecatedBlock = isDeprecated
    ? `
    if (__DEV__) {
      if (!didWarnAboutDeprecation) {
        didWarnAboutDeprecation = true;
        console.warn(
          \`The ${moduleName} component has been deprecated and will be \` +
          \`removed in the next major version of @carbon/icons-react.\`
        );
      }
    }
    `
    : '';
  const source = createIconSource(moduleName, descriptor, deprecatedBlock);
  return `${BANNER}
import React from 'react';
import Icon from './Icon.js';
${deprecatedPreamble}
${source}
export default ${moduleName};
`;
}

/**
 * Generate an icon component, which in our case is the string representation
 * of the component, from a given moduleName and icon descriptor.
 * @param {string} moduleName
 * @param {object} descriptor
 * @param {string} customBlock
 */
function createIconSource(moduleName, descriptor, customBlock = '') {
  const { attrs, content } = descriptor;
  const { width, height, viewBox, ...rest } = attrs;
  return `
    const ${moduleName} = /*#__PURE__*/ React.forwardRef(
      function ${moduleName}({ children, ...rest }, ref) {
        ${customBlock}
        return (
          <Icon
            width={${width}}
            height={${height}}
            viewBox="${viewBox}"
            ${formatAttributes(rest)}
            ref={ref}
            {...rest}>
            ${content.map(convertToJSX).join('\n')}
            {children}
          </Icon>
        );
      }
    );
  `;
}

/**
 * Convert the given node to a JSX string source
 * @param {object} node
 * @returns {string}
 */
function convertToJSX(node) {
  const { elem, attrs } = node;
  return `<${elem} ${formatAttributes(attrs)} />`;
}

const attributeDenylist = ['data', 'aria'];

/**
 * Determine if the given attribute should be transformed when being converted
 * to a React prop or if we should pass it through as-is
 * @param {string} attribute
 * @returns {boolean}
 */
function shouldTransformAttribute(attribute) {
  return attributeDenylist.every((prefix) => !attribute.startsWith(prefix));
}

/**
 * Serialize a given object of key, value pairs to an JSX-compatible string
 * @param {object} attrs
 * @returns {string}
 */
function formatAttributes(attrs) {
  return Object.keys(attrs).reduce((acc, key, index) => {
    const attribute = shouldTransformAttribute(key)
      ? `${camelCase(key)}="${attrs[key]}"`
      : `${key}="${attrs[key]}"`;

    if (index === 0) {
      return attribute;
    }
    return acc + ' ' + attribute;
  }, '');
}

module.exports = builder;
